/* kernel.c -- compile to 32-bit ELF object:
   i686-elf-gcc -m32 -ffreestanding -O2 -nostdlib -c kernel.c -o kernel.o
   or gcc -m32 -ffreestanding -nostdlib if using gcc-multilib
*/

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>

   //VGA text driver

static volatile uint16_t* const VGA = (uint16_t*)0xB8000;
static int vga_row = 0, vga_col = 0;
static uint8_t vga_color = 0x07;

static void vga_put_char(char c) {
    if (c == '\n') { vga_row++; vga_col = 0; return; }
    uint16_t entry = ((uint16_t)vga_color << 8) | (uint8_t)c;
    VGA[vga_row * 80 + vga_col] = entry;
    vga_col++;
    if (vga_col >= 80) { vga_col = 0; vga_row++; }
}

void kprint(const char* s) {
    for (size_t i = 0; s[i]; ++i) vga_put_char(s[i]);
}
void kputhex(uint32_t x) {
    const char *hex = "0123456789ABCDEF";
    kprint("0x");
    for (int i=7;i>=0;--i){
        char c = hex[(x >> (i*4)) & 0xF];
        vga_put_char(c);
    }
}


   //Simple bump allocator

static uint8_t *heap_ptr = (uint8_t*)0x00700000; /* 7MB start */
void* kmalloc(size_t sz) {
    void* p = (void*)heap_ptr;
    heap_ptr += sz;
    return p;
}


   //GDT structures (C-side)

struct gdt_entry {
    uint16_t limit_low;
    uint16_t base_low;
    uint8_t base_middle;
    uint8_t access;
    uint8_t gran;
    uint8_t base_high;
} __attribute__((packed));

struct gdt_ptr {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

static struct gdt_entry gdt_table[3];
static struct gdt_ptr gp;

extern void gdt_flush(uint32_t); /* assembly flips GDT; implemented in gdt.S/gdt_flush label */

static void gdt_set(int idx, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran){
    gdt_table[idx].limit_low = limit & 0xFFFF;
    gdt_table[idx].base_low = base & 0xFFFF;
    gdt_table[idx].base_middle = (base >> 16) & 0xFF;
    gdt_table[idx].access = access;
    gdt_table[idx].gran = ((limit >> 16) & 0x0F) | (gran & 0xF0);
    gdt_table[idx].base_high = (base >> 24) & 0xFF;
}

void gdt_install(void){
    gp.limit = sizeof(gdt_table) - 1;
    gp.base = (uint32_t)&gdt_table;
    gdt_set(0,0,0,0,0);
    gdt_set(1,0,0xFFFFFFFF,0x9A,0xCF); /* kernel code */
    gdt_set(2,0,0xFFFFFFFF,0x92,0xCF); /* kernel data */
    /* call assembly to load GDT */
    gdt_flush((uint32_t)&gp);
}

   //IDT & ISRs
struct idt_entry {
    uint16_t base_lo;
    uint16_t sel;
    uint8_t always0;
    uint8_t flags;
    uint16_t base_hi;
} __attribute__((packed));

struct idt_ptr {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

static struct idt_entry idt[256];
static struct idt_ptr idtp;

extern void idt_load(uint32_t);

static void idt_set(int n, uint32_t base, uint16_t sel, uint8_t flags) {
    idt[n].base_lo = base & 0xFFFF;
    idt[n].base_hi = (base >> 16) & 0xFFFF;
    idt[n].sel = sel;
    idt[n].always0 = 0;
    idt[n].flags = flags;
}

/* We'll use external stubs generated by isr.s: isr_stub_0 .. isr_stub_47 */
extern void isr_stub_0();  extern void isr_stub_1();  extern void isr_stub_2();  extern void isr_stub_3();
extern void isr_stub_4();  extern void isr_stub_5();  extern void isr_stub_6();  extern void isr_stub_7();
extern void isr_stub_8();  extern void isr_stub_9();  extern void isr_stub_10(); extern void isr_stub_11();
extern void isr_stub_12(); extern void isr_stub_13(); extern void isr_stub_14(); extern void isr_stub_15();
extern void isr_stub_16(); extern void isr_stub_17(); extern void isr_stub_18(); extern void isr_stub_19();
extern void isr_stub_20(); extern void isr_stub_21(); extern void isr_stub_22(); extern void isr_stub_23();
extern void isr_stub_24(); extern void isr_stub_25(); extern void isr_stub_26(); extern void isr_stub_27();
extern void isr_stub_28(); extern void isr_stub_29(); extern void isr_stub_30(); extern void isr_stub_31();
extern void isr_stub_32(); extern void isr_stub_33(); extern void isr_stub_34(); extern void isr_stub_35();
extern void isr_stub_36(); extern void isr_stub_37(); extern void isr_stub_38(); extern void isr_stub_39();
extern void isr_stub_40(); extern void isr_stub_41(); extern void isr_stub_42(); extern void isr_stub_43();
extern void isr_stub_44(); extern void isr_stub_45(); extern void isr_stub_46(); extern void isr_stub_47();

static void isr_install(void) {
    idt_set(0,  (uint32_t)isr_stub_0,  0x08, 0x8E);
    idt_set(1,  (uint32_t)isr_stub_1,  0x08, 0x8E);
    idt_set(2,  (uint32_t)isr_stub_2,  0x08, 0x8E);
    idt_set(3,  (uint32_t)isr_stub_3,  0x08, 0x8E);
    idt_set(4,  (uint32_t)isr_stub_4,  0x08, 0x8E);
    idt_set(5,  (uint32_t)isr_stub_5,  0x08, 0x8E);
    idt_set(6,  (uint32_t)isr_stub_6,  0x08, 0x8E);
    idt_set(7,  (uint32_t)isr_stub_7,  0x08, 0x8E);
    idt_set(8,  (uint32_t)isr_stub_8,  0x08, 0x8E);
    idt_set(9,  (uint32_t)isr_stub_9,  0x08, 0x8E);
    idt_set(10, (uint32_t)isr_stub_10, 0x08, 0x8E);
    idt_set(11, (uint32_t)isr_stub_11, 0x08, 0x8E);
    idt_set(12, (uint32_t)isr_stub_12, 0x08, 0x8E);
    idt_set(13, (uint32_t)isr_stub_13, 0x08, 0x8E);
    idt_set(14, (uint32_t)isr_stub_14, 0x08, 0x8E);
    idt_set(15, (uint32_t)isr_stub_15, 0x08, 0x8E);
    idt_set(16, (uint32_t)isr_stub_16, 0x08, 0x8E);
    idt_set(17, (uint32_t)isr_stub_17, 0x08, 0x8E);
    idt_set(18, (uint32_t)isr_stub_18, 0x08, 0x8E);
    idt_set(19, (uint32_t)isr_stub_19, 0x08, 0x8E);
    idt_set(20, (uint32_t)isr_stub_20, 0x08, 0x8E);
    idt_set(21, (uint32_t)isr_stub_21, 0x08, 0x8E);
    idt_set(22, (uint32_t)isr_stub_22, 0x08, 0x8E);
    idt_set(23, (uint32_t)isr_stub_23, 0x08, 0x8E);
    idt_set(24, (uint32_t)isr_stub_24, 0x08, 0x8E);
    idt_set(25, (uint32_t)isr_stub_25, 0x08, 0x8E);
    idt_set(26, (uint32_t)isr_stub_26, 0x08, 0x8E);
    idt_set(27, (uint32_t)isr_stub_27, 0x08, 0x8E);
    idt_set(28, (uint32_t)isr_stub_28, 0x08, 0x8E);
    idt_set(29, (uint32_t)isr_stub_29, 0x08, 0x8E);
    idt_set(30, (uint32_t)isr_stub_30, 0x08, 0x8E);
    idt_set(31, (uint32_t)isr_stub_31, 0x08, 0x8E);

    /* IRQs 32..47 */
    for (int i=32;i<48;++i) {
        /* map their stubs; we'll rely on symbol names defined in assembly */
        extern void *isr_stub_32;
        /* set individually as above to avoid name gymnastics */
    }
    /* manually set 32..47 */
    idt_set(32, (uint32_t)isr_stub_32, 0x08, 0x8E); idt_set(33,(uint32_t)isr_stub_33,0x08,0x8E);
    idt_set(34,(uint32_t)isr_stub_34,0x08,0x8E); idt_set(35,(uint32_t)isr_stub_35,0x08,0x8E);
    idt_set(36,(uint32_t)isr_stub_36,0x08,0x8E); idt_set(37,(uint32_t)isr_stub_37,0x08,0x8E);
    idt_set(38,(uint32_t)isr_stub_38,0x08,0x8E); idt_set(39,(uint32_t)isr_stub_39,0x08,0x8E);
    idt_set(40,(uint32_t)isr_stub_40,0x08,0x8E); idt_set(41,(uint32_t)isr_stub_41,0x08,0x8E);
    idt_set(42,(uint32_t)isr_stub_42,0x08,0x8E); idt_set(43,(uint32_t)isr_stub_43,0x08,0x8E);
    idt_set(44,(uint32_t)isr_stub_44,0x08,0x8E); idt_set(45,(uint32_t)isr_stub_45,0x08,0x8E);
    idt_set(46,(uint32_t)isr_stub_46,0x08,0x8E); idt_set(47,(uint32_t)isr_stub_47,0x08,0x8E);

    idtp.limit = sizeof(idt) - 1;
    idtp.base = (uint32_t)&idt;
    idt_load((uint32_t)&idtp);
}


   //PIC remap and helpers

static inline void outb(uint16_t port, uint8_t val) {
    asm volatile ("outb %0, %1" : : "a"(val), "Nd"(port));
}
static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    asm volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

void pic_remap(void) {
    outb(0x20, 0x11);
    outb(0xA0, 0x11);
    outb(0x21, 0x20);
    outb(0xA1, 0x28);
    outb(0x21, 4);
    outb(0xA1, 2);
    outb(0x21, 1);
    outb(0xA1, 1);
    outb(0x21, 0x0);
    outb(0xA1, 0x0);
}


 //  IRQ handlers: keyboard & pit

#define KEYBOARD_DATA_PORT 0x60
#define PIC1_COMMAND 0x20
#define PIC1_END     0x20
#define PIC2_COMMAND 0xA0
#define PIC2_END     0xA0

void irq_handler(int irq) {
    if (irq == 0) {
        /* PIT tick */
        static uint32_t ticks = 0;
        ticks++;
        if ((ticks % 100) == 0) {
            kprint("\n[TICK] ");
            kputhex(ticks);
            kprint("\n");
        }
    } else if (irq == 1) {
        /* keyboard */
        uint8_t sc = inb(KEYBOARD_DATA_PORT);
        kprint("\nSC: ");
        kputhex(sc);
        kprint("\n");
    }
    /* send end of interrupt */
    if (irq >= 8) outb(0xA0, 0x20);
    outb(0x20, 0x20);
}


   // Common ISR / IRQ entry points (C-callable from assembly)

struct regs {
    uint32_t ds;
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
    uint32_t int_no, err_code;
    uint32_t eip, cs, eflags, useresp, ss;
};

void isr_handler(struct regs *r) {
    kprint("\n[EXC] Int: ");
    kputhex(r->int_no);
    kprint("\n");
    /* for now just hang on faults */
    if (r->int_no >= 8 && r->int_no <= 31) {
        kprint("CPU Exception, halting.\n");
        for(;;) asm volatile("hlt");
    }
}

/* isr_common_stub & irq_common_stub are implemented in assembly (see next file) */
extern void isr_common_stub(void);
extern void irq_common_stub(void);


  // PIT (timer) init

void pit_init(uint32_t frequency) {
    uint32_t divisor = 1193180 / frequency;
    outb(0x43, 0x36);
    outb(0x40, divisor & 0xFF);
    outb(0x40, (divisor >> 8) & 0xFF);
}


  // Tiny shell

static char cmdbuf[128];
static int cmdpos = 0;

void shell_putc(char c) {
    if (c == '\n') { kprint("\n> "); cmdpos = 0; cmdbuf[0]=0; return; }
    if (c == '\b') {
        kprint("\b \b");
        if (cmdpos > 0) cmdpos--;
        cmdbuf[cmdpos] = 0;
        return;
    }
    vga_put_char(c);
    if (cmdpos < (int)sizeof(cmdbuf)-1) {
        cmdbuf[cmdpos++] = c;
        cmdbuf[cmdpos] = 0;
    }
}

void process_command(const char* s) {
    if (!s) return;
    if (s[0] == 0) return;
    kprint("\nYou typed: ");
    kprint(s);
    kprint("\n");
    if (s[0]=='h') {
        kprint("Commands: help, hex, time\n");
    }
}

/* rudimentary polling to demonstrate shell (keyboard IRQ will print scancodes; for real input you'd translate scancodes) */
void shell_loop(void) {
    kprint("> ");
    for(;;) {
        asm volatile ("hlt");
    }
}

//
   IDT load helper (assembly implemented in idt.S)

extern void idt_load(uint32_t);


 //  Kernel entry

void kernel_main(void) {
    /* clear screen */
    for (int i=0;i<80*25;i++) VGA[i] = 0x0720;

    kprint("MyOS C Kernel booting...\n");
    gdt_install();
    kprint("GDT installed.\n");

    /* Install IDT entries and ISRs (stubs are in isr.s) */
    isr_install();
    kprint("IDT entries set (stubs loaded locally in C wrapper).\n");

    pic_remap();
    kprint("PIC remapped.\n");

    pit_init(100); /* 100 Hz */
    kprint("PIT initialized.\n");

    /* enable IRQs: unmask keyboard (1) and PIT (0) */
    outb(0x21, 0xFC); /* mask everything except IRQ0 & IRQ1 */
    outb(0xA1, 0xFF);

    idt_load((uint32_t)&idt); /* actually load IDT */

    kprint("IDT loaded.\n");
    kprint("System ready. Type on keyboard or watch ticks.\n");

    shell_loop();
}

/* Provide minimal symbols used by assembly */
void gdt_flush(uint32_t ptr) {
    /* assembly gdt_flush expects pointer on stack; call it properly */
    asm volatile ("push %0; call gdt_flush; add $4, %%esp" :: "r"(ptr) : );
}

